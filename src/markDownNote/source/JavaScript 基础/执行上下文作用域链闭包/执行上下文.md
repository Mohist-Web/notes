# 执行上下文 #
首先来读两段面试中常遇到的代码
```
function foo() {
    console.log(a);
}

function bar() {
    var a = 3;
    foo();
}

var a = 2;
bar();
```

```
var b = 1;
function bar() {
    if (!b) {
        var b = 10;
    }
    console.log(b);
}
bar();
```
此处抛出两个疑问:
1. 第一段代码执行结果是 2, 你是否会疑惑在 function 作用域内不是先查找本作用域的变量, 找不到才沿作用域链往上找吗? 为什么 函数内有 var a = 3,但是foo还是引用全局的 a = 2 呢? 
2. 第一段代码执行结果是 10, 你是否会疑惑为啥 foo 会是 10, 难道 var foo = 10 被执行了? 函数内打印 foo 的值为什么会是 undefined? 

针对这种代码中的现象, 我也是看了很多帖子文章, 看这些文章的时候, 发现短短几行代码, 涉及的知识点还挺多: 变量提升、scope、静态作用域、词法环境、执行上下文等等.从中大概知道函数的作用域是在它创建的时候的词法环境决定的, 但this是在运行时决定的不是在创建时决定的.
为了彻底了解自己写的代码到底再干些啥, 我们必须了解清楚.

## 执行上下文(Execution Context) ##
#### 什么是执行上下文 ####
简而言之, 执行上下文是评估和执行 JavaScript 代码的环境的抽象概念.每当 Javascript 代码在运行的时候, 它都是在执行上下文中运行.

#### 执行上下文的类型 ####
JavaScript 中有三种执行上下文类型.
> 1. 全局执行上下文 — 这是默认或者说基础的上下文, 任何不在函数内部的代码都在全局上下文中.它会执行两件事：创建一个全局的 window 对象（浏览器的情况下）, 并且设置 this 的值等于这个全局对象.一个程序中只会有一个全局执行上下文.
> 
> 2. 函数执行上下文 — 每当一个函数被调用时,  都会为该函数创建一个新的上下文.每个函数都有它自己的执行上下文, 不过是在函数被调用时创建的.函数上下文可以有任意多个.每当一个新的执行上下文被创建, 它会按定义的顺序（将在后文讨论）执行一系列步骤.
> 
> 3. Eval 函数执行上下文 — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文, 但由于 JavaScript 开发者并不经常使用 eval, 所以在这里我不会讨论它.


#### 执行栈 ####
执行栈, 也就是在其它编程语言中所说的“调用栈”, 是一种拥有 LIFO（后进先出）数据结构的栈, 被用来存储代码运行时创建的所有执行上下文.
当 JavaScript 引擎第一次遇到你的脚本时, 它会创建一个全局的执行上下文并且压入当前执行栈.每当引擎遇到一个函数调用, 它会为该函数创建一个新的执行上下文并压入栈的顶部.
引擎会执行那些执行上下文位于栈顶的函数.当该函数执行结束时, 执行上下文从栈中弹出, 控制流程到达当前栈中的下一个上下文.

#### 怎么创建执行上下文?  ####
创建执行上下文有两个阶段:
1. 创建阶段(The Creation Phase)
2. 执行阶段

在 JavaScript 代码执行前, 执行上下文将经历创建阶段.在创建阶段会发生三件事：
> 1. this 值的决定(This Binding), 即我们所熟知的 This 绑定.
> 2. 创建词法环境组件(Lexical Environments).
> 3. 创建变量环境组件(Variable Environment ).

这里我就直接借鉴了他人翻译资料的伪代码, 来表示这个创建过程：

```
ExecutionContext = {  
    // 确定this的值
    ThisBinding = <this value>, 
    // 创建词法环境组件
    LexicalEnvironment = {}, 
    // 创建变量环境组件
    VariableEnvironment = {}, 
};

```

#### This 绑定： ####
在全局执行上下文中, this 的值指向全局对象.(在浏览器中, this引用 Window 对象).
在函数执行上下文中, this 的值取决于该函数是如何被调用的.如果它被一个引用对象调用, 那么 this 会被设置成那个对象, 否则 this 的值被设置为全局对象或者 undefined（在严格模式下）.



#### 词法环境： ####
官方的 ES6 文档把词法环境定义为
> 词法环境是一种规范类型, 基于 ECMAScript 代码的词法嵌套结构来定义标识符和具体变量和函数的关联.一个词法环境由环境记录器和一个可能的引用外部词法环境的空值组成.

简单来说词法环境是一种持有标识符—变量映射的结构.（这里的标识符指的是变量/函数的名字, 而变量是对实际对象[包含函数类型对象]或原始数据的引用）.

现在, 在词法环境的内部有两个组件：
1. 环境记录器, 是存储变量和函数声明的实际位置.
2. 一个外部环境的引用, 意味着它可以访问其父级词法环境（作用域）.

词法环境有两种类型：
1. 全局环境（在全局执行上下文中）是没有外部环境引用的词法环境.全局环境的外部环境引用是 null.它拥有内建的 Object/Array/等、在环境记录器内的原型函数（关联全局对象, 比如 window 对象）还有任何用户定义的全局变量, 并且 this的值指向全局对象.
2. 在函数环境中, 函数内部用户定义的变量存储在环境记录器中.并且引用的外部环境可能是全局环境, 或者任何包含此内部函数的外部函数.

环境记录器也有两种类型（如上！）：
1. 声明式环境记录器存储变量、函数和参数.
2. 对象环境记录器用来定义出现在全局上下文中的变量和函数的关系.
简而言之, 在全局环境中, 环境记录器是对象环境记录器.在函数环境中, 环境记录器是声明式环境记录器.要注意的是,  对于函数环境, 声明式环境记录器还包含了一个传递给函数的 arguments 对象（此对象存储索引和参数的映射）和传递给函数的参数的 length.

这一段比较抽象, 用伪代码表示是这样：
```
GlobalExectionContext = {
    LexicalEnvironment: {
        EnvironmentRecord: {
            Type: "Object", 
            // 在这里绑定标识符
        }, 
        outer: <null>
    }
}

FunctionExectionContext = {
    LexicalEnvironment: {
        EnvironmentRecord: {
            Type: "Declarative", 
            // 在这里绑定标识符
        }, 
        outer: <Global or outer function environment reference>
    }
}
```


#### 变量环境： ####
它同样是一个词法环境, 其环境记录器持有变量声明语句在执行上下文中创建的绑定关系.
如上所述, 变量环境也是一个词法环境, 所以它有着上面定义的词法环境的所有属性.
在 ES6 中, 词法环境组件和变量环境的唯一不同就是前者被用来存储函数声明和变量（let 和 const）绑定, 而后者只用来存储 var 变量绑定.
同样, 这一段也比较抽象, 用伪代码表示是这样：
```
let a = 20;
const b = 30;
var c;

function multiply(e,  f) {
    var g = 20;
    return e * f * g;
}

c = multiply(20,  30);
```

```
GlobalExectionContext = {
    ThisBinding: <Global Object>, 
    LexicalEnvironment: {
        EnvironmentRecord: {
            Type: "Object", 
            // 在这里绑定标识符
            a: < uninitialized >, 
            b: < uninitialized >, 
            multiply: < func >
        }, 
        outer: <null>
    }, 
    VariableEnvironment: {
        EnvironmentRecord: {
            Type: "Object", 
            // 在这里绑定标识符
            c: undefined, 
        }, 
        outer: <null>
    }
}

FunctionExectionContext = {
    ThisBinding: <Global Object>, 
    LexicalEnvironment: {
        EnvironmentRecord: {
            Type: "Declarative", 
            // 在这里绑定标识符
            Arguments: { 0: 20,  1: 30,  length: 2 }, 
        }, 
        outer: <GlobalLexicalEnvironment>
    }, 
    VariableEnvironment: {
        EnvironmentRecord: {
            Type: "Declarative", 
            // 在这里绑定标识符
            g: undefined
        }, 
        outer: <GlobalLexicalEnvironment>
    }
}
```
需要注意的是, 只有遇到调用函数 multiply 时, 函数执行上下文才会被创建.


#### 变量提升和临时性死区： ####
可能你已经注意到 let 和 const 定义的变量并没有关联任何值, 但 var 定义的变量被设成了 undefined.
这是因为在创建阶段时, 引擎检查代码找出变量和函数声明, 虽然函数声明完全存储在环境中, 但是变量最初设置为 undefined（var 情况下）, 或者未初始化（let 和 const 情况下）.
这就是为什么你可以在声明之前访问 var 定义的变量（虽然是 undefined）, 但是在声明之前访问 let 和 const 的变量会得到一个引用错误.这就是我们说的变量声明提升.
其实照这样说let const class 生命的变量也都是有提升的, 只是提升的时候没有初始化, 不能使用, 这种变量已经创建绑定完, 没有初始化这种状态, 叫做临时死区.
为了防止概念混淆, 在这里做一个步骤详解:
>   
1. 创建执行上下文, 并加入栈顶
2. 分析:
	-找到所有的非函数中的var声明
	-找到所有的顶级函数声明
	-找到所有的let const class声明
	-找到块中的声明, 函数名不与上述重复
3. 名字重复处理
4. 创建绑定
	-登记并初始化 var 为undefined
	-顶级函数声明:登记 function 名字, 并初始化为新创建函数对象
	-块级中函数声明: 登记名字, 初始化为 undefined
	-登记 let const class, 但未初始化 uninitialized
5. 执行语句


#### 执行阶段 ####
这是整篇文章中最简单的部分.在此阶段, 完成对所有这些变量的分配, 最后执行代码.


## 结语 ##
现在回到我们最开始提出的问题
1. 因为我们 foo 方法实在全局上下文中创建的, 函数中也未对 a 进行声明, 所以去 outer 里面寻找 a 的值, 取到了 2.这里牵扯到一个作用域的问题, 所谓作用域就是当前执行上下文得文本环境, 作用域是解析(查找)变量名的一个集合, 就是当前运行上下文(也可以是当前上下文的词法环境);全局作用域就是全局运行上下文, 函数作用域就是函数运行上下文, 这里教大家一个小诀窍: 当函数调用时, 判断执行上下文要看身世-函数在哪里创建, 就保存哪里得运行上下文, 所以函数得作用域是在函数创建时决定的而不是调用时决定的, 并非根据调用嵌套形成(运行上下文)作用域链, 而是根据函数创建嵌套形成作用域链, 也就是函数得书写位置形成作用域链, 因此称为词法作用域
2. 我们在 if 之前打印一下 b 的值就会发现是 undefined, 所以if 代码块里面的代码运行了.

	 